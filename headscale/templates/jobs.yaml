{{ if and .Values.headscale.keys.create (not .Values.headscale.keys.existingSecret ) }}
{{ $name := (print ( include "headscale.fullname" . ) "-keys") }}
{{ $secretName := (print ( include "headscale.fullname" . ) "-keys") }}
---
apiVersion: v1
kind: Secret
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/resource-policy: keep
  name: {{ $name }}
type: Opaque
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ $name }}
  labels:
    app.kubernetes.io/component: keys-job
    {{- include "headscale.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ $name }}
  labels:
    app.kubernetes.io/component: keys-job
    {{- include "headscale.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
    resourceNames:
      - {{ $secretName }}
    verbs:
      - get
      - update
      - patch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ $name }}
  labels:
    app.kubernetes.io/component: keys-job
    {{- include "headscale.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $name }}
subjects:
  - kind: ServiceAccount
    name: {{ $name }}
    namespace: {{ .Release.Namespace }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $name }}
  labels:
    {{- include "headscale.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
spec:
  template:
    spec:
      restartPolicy: Never
      serviceAccount: {{ $name }}
      initContainers:
       - name: generate-key
         {{- with .Values.image }}
         image: {{ .registry }}/{{ .repository }}:{{ .tag | default $.Chart.AppVersion }}-debug
         {{- end }}
         imagePullPolicy: {{ .Values.image.pullPolicy }}
         command:
          - sh
          - -c
          - |
            set -e
            echo "generate private-keys"
            headscale generate private-key --output json > /etc/headscale/secrets/wireguard.json
            headscale generate private-key --output json > /etc/headscale/secrets/noise.json
            headscale generate private-key --output json > /etc/headscale/secrets/derp.json
            ls /etc/headscale/secrets/
         volumeMounts:
          - name: config
            mountPath: /etc/headscale
            readOnly: true
          - mountPath: /etc/headscale/secrets
            name: secrets
      containers:
       - name: upload-key
         image: bitnami/kubectl
         command:
          - sh
          - -c
          - |
            # check if key already exists
            key=$(kubectl get secret {{ $secretName }} -o jsonpath="{.data}" 2> /dev/null)
            [ $? -ne 0 ] && echo "Failed to get existing secret" && exit 1
            if ! echo $key | jq -e 'has("wireguard.key")' 2> /dev/null ; then
              echo "store wireguard.key"
              kubectl patch secret {{ $secretName }} -p "{\"data\":{\"wireguard.key\":\"$(jq -r '.["private_key"] | split(":")[1] | @base64' /etc/headscale/secrets/wireguard.json)\"}}"
            fi
            if ! echo $key | jq -e 'has("noise.key")' 2> /dev/null ; then
              echo "store noise.key"
              kubectl patch secret {{ $secretName }} -p "{\"data\":{\"noise.key\":\"$(jq -r '.["private_key"] | @base64' /etc/headscale/secrets/noise.json)\"}}"
            elif ! echo $key | jq -e '.["noise.key"] |@base64d | contains("privkey")' 2> /dev/null ; then
              echo "patch noise.key"
              newKey="privkey:$(echo $key | jq -r '.["noise.key"]|@base64d')"
              kubectl patch secret {{ $secretName }} -p "{\"data\":{\"noise.key\":\"$(echo $newKey | base64 -w0)\"}}"
            fi
            if ! echo $key | jq -e 'has("derp.key")' 2> /dev/null ; then
              echo "store derp.key"
              kubectl patch secret {{ $secretName }} -p "{\"data\":{\"derp.key\":\"$(jq -r '.["private_key"] | @base64' /etc/headscale/secrets/derp.json)\"}}"
            fi
            [ $? -ne 0 ] && echo "Failed to update secret." && exit 1
            echo "Signing key successfully created."
         volumeMounts:
          - mountPath: /etc/headscale/secrets
            name: secrets
            readOnly: true
      volumes:
       - name: config
         secret:
           secretName: {{ include "headscale.fullname" . }}
           items:
            - key: config.yaml
              path: config.yaml
       - name: secrets
         emptyDir: {}
  parallelism: 1
  completions: 1
  backoffLimit: 1
{{ end }}
{{ if .Values.headplane.enabled }}
---
apiVersion: v1
kind: Secret
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/resource-policy: keep
  name: {{ include "headscale.fullname" . }}-api-key
type: Opaque
stringData:
  HEADPLANE_OIDC__HEADSCALE_API_KEY: placeholder-token-will-be-replaced-by-job
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "headscale.fullname" . }}-api-key
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ include "headscale.fullname" . }}-api-key
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
rules:
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "get", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ include "headscale.fullname" . }}-api-key
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
subjects:
  - kind: ServiceAccount
    name: {{ include "headscale.fullname" . }}-api-key
    namespace: {{ .Release.Namespace }}
roleRef:
  kind: Role
  name: {{ include "headscale.fullname" . }}-api-key
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
  name: {{ include "headscale.fullname" . }}-api-key
spec:
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "headscale.fullname" . }}-api-key
      containers:
        - name: {{ include "headscale.fullname" . }}-api-key
          image: bitnami/kubectl:latest
          command:
            - /bin/sh
            - -c
            - |
              set -e

              echo "Waiting for headscale container to be Ready..."
              while [ -z "$CONTAINER_STATUS" ]; do
              POD_NAME=$(kubectl -n {{ .Release.Namespace }} get pod -l app.kubernetes.io/name={{ include "headscale.fullname" . }} -o=jsonpath="{.items[0].metadata.name}")
              CONTAINER_STATUS=$(kubectl -n {{ .Release.Namespace }} get pod/${POD_NAME} -o=jsonpath="{.status.containerStatuses[?(@.name==\"headscale\")].state.running}")
                sleep 1
              done

              echo "Checking if API token needs to be generated..."
              if kubectl get secret {{ include "headscale.fullname" . }}-api-key -n {{ .Release.Namespace }} >/dev/null 2>&1; then
                CURRENT_TOKEN=$(kubectl get secret {{ include "headscale.fullname" . }}-api-key -n {{ .Release.Namespace }} -o jsonpath='{.data.HEADPLANE_OIDC__HEADSCALE_API_KEY}' | base64 -d)
                echo "Current token value: '$CURRENT_TOKEN'"
                echo "Current token length: ${#CURRENT_TOKEN}"
                echo "Expected placeholder: 'placeholder-token-will-be-replaced-by-job'"
                echo "Expected length: 42"
                if [[ "$CURRENT_TOKEN" != "placeholder-token-will-be-replaced-by-job" ]]; then
                  echo "Real API token already exists. Skipping token generation."
                  exit 0
                else
                  echo "Placeholder token found. Generating real API token..."
                fi
              else
                echo "Secret not found. Generating API token..."
              fi

              echo "Generating Headscale API token..."
              TOKEN=$(kubectl -n {{ .Release.Namespace }} exec -i pod/${POD_NAME} -c headscale -- headscale apikeys create -e 100y)

              if [ -z "$TOKEN" ]; then
                echo "Failed to retrieve API token"
                exit 1
              fi

              echo "Updating {{ include "headscale.fullname" . }}-api-key secret with generated API token..."
              kubectl patch secret {{ include "headscale.fullname" . }}-api-key -n {{ .Release.Namespace }} -p="{\"data\":{\"HEADPLANE_OIDC__HEADSCALE_API_KEY\":\"$(echo -n "$TOKEN" | base64)\"}}"

              echo "Successfully updated {{ include "headscale.fullname" . }}-api-key secret with real API token"
  parallelism: 1
  completions: 1
  backoffLimit: 1
{{ end }}
