global:
  image:
    # -- if set it will overwrite all registry entries
    registry:
    # -- if set it will overwrite all pullPolicy
    pullPolicy:

replicaCount: 1

image:
  registry: dock.mau.dev
  repository: mautrix/signal
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

config:
  # Bridge config
  bridge:
    # -- The prefix for commands. Only required in non-management rooms.
    command_prefix: '!signal'
    # -- Should the bridge create a space for each logged-in user and add bridged rooms to it?
    # Users who logged in before turning this on should run `!signal sync-space` to create and fill the space for the first time.
    personal_filtering_spaces: false
    # -- Whether to explicitly set the avatar and room name for private chat portal rooms.
    # If set to `default`, this will be enabled in encrypted rooms and disabled in unencrypted rooms.
    # If set to `always`, all DM rooms will have explicit names and avatars set.
    # If set to `never`, DM rooms will never have names and avatars set.
    private_chat_portal_meta: default
    bridge_matrix_leave:
    tag_only_on_create:
    mute_only_on_create:
    cleanup_on_logout:
      enabled:
      manual:
        private:
        relayed:
        shared_no_users:
        shared_has_users:
      bad_credentials:
        private:
        relayed:
        shared_no_users:
        shared_has_users:

    # Settings for relay mode
    relay:
      # -- Whether relay mode should be allowed. If allowed, `!wa set-relay` can be used to turn any
      # authenticated user into a relaybot for that chat.
      enabled: false
      # -- Should only admins be allowed to set themselves as relay users?
      admin_only: true
      default_relays:
      # -- The formats to use when sending messages to Signal via the relaybot.
      message_formats:
        m.text: "<b>{{ .Sender.Displayname }}</b>: {{ .Message }}"
        m.notice: "<b>{{ .Sender.Displayname }}</b>: {{ .Message }}"
        m.emote: "* <b>{{ .Sender.Displayname }}</b> {{ .Message }}"
        m.file: "<b>{{ .Sender.Displayname }}</b> sent a file"
        m.image: "<b>{{ .Sender.Displayname }}</b> sent an image"
        m.audio: "<b>{{ .Sender.Displayname }}</b> sent an audio file"
        m.video: "<b>{{ .Sender.Displayname }}</b> sent a video"
        m.location: "<b>{{ .Sender.Displayname }}</b> sent a location"
      displayname_format: ""
  
    # Permissions for using the bridge.
    # Permitted values:
    #    block -
    #    relay - Talk through the relaybot (if enabled), no access otherwise
    # commands - 
    #     user - Access to use the bridge to chat with a Signal account.
    #    admin - User level and some additional administration tools
    # Permitted keys:
    #        * - All Matrix users
    #   domain - All users on that homeserver
    #     mxid - Specific user
    permissions:
      "*": relay
      "example.com": user
      "@admin:example.com": admin


  # Database config.
  database:
    # -- The database type. "sqlite3-fk-wal" and "postgres" are supported.
    type: postgres
    # -- The database URI.
    #   SQLite: A raw file path is supported, but `file:<path>?_txlock=immediate` is recommended.
    #           https://github.com/mattn/go-sqlite3#connection-string
    #   Postgres: Connection string. For example, postgres://user:password@host/database?sslmode=disable
    #             To connect via Unix socket, use something like postgres:///dbname?host=/var/run/postgresql
    uri: postgres://user:password@host/database?sslmode=disable
    # -- Maximum number of connections. Mostly relevant for Postgres.
    max_open_conns: 20
    max_idle_conns: 2
    # -- Maximum connection idle time and lifetime before they're closed. Disabled if null.
    # Parsed with https://pkg.go.dev/time#ParseDuration
    max_conn_idle_time: null
    max_conn_lifetime: null

  # Homeserver details.
  homeserver:
    # -- The address that this appservice can use to connect to the homeserver.
    address: https://matrix.example.com
    # -- The domain of the homeserver (also known as server_name, used for MXIDs, etc).
    domain: example.com
    # -- Does the homeserver support https://github.com/matrix-org/matrix-spec-proposals/pull/2246?
    async_media: false
    public_address:

    # -- What software is the homeserver running?
    # Standard Matrix homeservers like Synapse, Dendrite and Conduit should just use "standard" here.
    software: standard
    # -- The URL to push real-time bridge status to.
    # If set, the bridge will make POST requests to this URL whenever a user's Signal connection state changes.
    # The bridge will use the appservice as_token to authorize requests.
    status_endpoint: null
    # -- Endpoint for reporting per-message status.
    message_send_checkpoint_endpoint: null

    # -- Should the bridge use a websocket for connecting to the homeserver?
    # The server side is currently not documented anywhere and is only implemented by mautrix-wsproxy,
    # mautrix-asmux (deprecated), and hungryserv (proprietary).
    websocket: false
    websocket_proxy: ""
    # -- How often should the websocket be pinged? Pinging will be disabled if this is zero.
    ping_interval_seconds: 0

  
  # Application service host/registration related details.
  # Changing these values requires regeneration of the registration.
  appservice:
    # -- The address that the homeserver can use to connect to this appservice.
    address: http://localhost:29328
    public_address:
    # -- The hostname and port where this appservice should listen.
    hostname: 0.0.0.0
    port: 29328

    # -- The unique ID of this appservice.
    id: signal
    # Appservice bot details.
    bot:
      # -- Username of the appservice bot.
      username: signalbot
      # -- Display name and avatar for bot. Set to "remove" to remove display name/avatar, leave empty
      # to leave display name/avatar as-is.
      displayname: Signal bridge bot
      avatar: mxc://maunium.net/wPJgTQbZOtpBFmDNkiNEMDUp

    as_token: ""
    hs_token: ""

    # -- Whether or not to receive ephemeral events via appservice transactions.
    # Requires MSC2409 support (i.e. Synapse 1.22+).
    ephemeral_events: true
    # -- Should incoming events be handled asynchronously?
    # This may be necessary for large public instances with lots of messages going through.
    # However, messages will not be guaranteed to be bridged in the same order they were sent in.
    async_transactions: false

    # -- Localpart template of MXIDs for Signal users.
    # {{.}} is replaced with the internal ID of the Signal user.
    username_template: signal_{{.}}

  matrix:
    # -- Should the bridge send a read receipt from the bridge bot when a message has been sent to Signal?
    delivery_receipts: false
    # -- Whether the bridge should send the message status as a custom com.beeper.message_send_status event.
    message_status_events: false
    # -- Whether the bridge should send error notices via m.notice events when a message fails to bridge.
    message_error_notices: true
    # -- Should the bridge update the m.direct account data event when double puppeting is enabled.
    # Note that updating the m.direct event is not atomic (except with mautrix-asmux)
    # and is therefore prone to race conditions.
    sync_direct_chat_list: false
    # -- Whether or not created rooms should have federation enabled.
    # If false, created portal rooms will never be federated.
    federate_rooms: true
    
  # Settings for provisioning API
  provisioning:
    # -- Prefix for the provisioning API paths.
    prefix: /_matrix/provision
    # -- Shared secret for authentication. If set to "generate", a random secret will be generated,
    # or if set to "disable", the provisioning API will be disabled.
    shared_secret: generate
    # -- Enable debug API at /debug with provisioning authentication.
    debug_endpoints: false

  public_media:
    enabled: false
    signing_key: ""
    hash_length: 0
    expiry: 0

  direct_media:
    enabled: false
    media_id_prefix: ""
    server_name: ""
    server_key: ""
    allow_proxy: false
    well_known_response: ""

  backfill:
    enabled: false
    max_initial_messages:
    max_catchup_messages:
    unread_hours_threshold:
    threads:
      max_initial_messages:
    queue:
      enabled:
      batch_size:
      batch_delay:
      max_batches: 10
      max_batches_override:
        "a": 10

  double_puppet:
    # -- Allow using double puppeting from any server with a valid client .well-known file.
    allow_discovery: false
    # -- Servers to always allow double puppeting from
    servers:
      example.com: https://example.com
    # -- Shared secrets for https://github.com/devture/matrix-synapse-shared-secret-auth
    #
    # If set, double puppeting will be enabled automatically for local users
    # instead of users having to find an access token and run `login-matrix`
    # manually.
    secrets:
      example.com: foobar

  # End-to-bridge encryption support options.
  #
  # See https://docs.mau.fi/bridges/general/end-to-bridge-encryption.html for more info.
  encryption:
    # -- Allow encryption, work in group chat rooms with e2ee enabled
    allow: false
    # -- Default to encryption, force-enable encryption in all portals the bridge creates
    # This will cause the bridge bot to be in private chats for the encryption to work properly.
    default: false
    # -- Require encryption, drop any unencrypted messages.
    require: false
    # -- Whether to use MSC2409/MSC3202 instead of /sync long polling for receiving encryption-related data.
    appservice: false
    plaintext_mentions:
    pickle_key:
    # -- Options for deleting megolm sessions from the bridge.
    delete_keys:
      # -- Beeper-specific: delete outbound sessions when hungryserv confirms
      # that the user has uploaded the key to key backup.
      delete_outbound_on_ack: false
      # -- Don't store outbound sessions in the inbound table.
      dont_store_outbound: false
      # -- Ratchet megolm sessions forward after decrypting messages.
      ratchet_on_decrypt: false
      # -- Delete fully used keys (index >= max_messages) after decrypting messages.
      delete_fully_used_on_decrypt: false
      # -- Delete previous megolm sessions from same device when receiving a new one.
      delete_prev_on_new_session: false
      # -- Delete megolm sessions received from a device when the device is deleted.
      delete_on_device_delete: false
      # -- Periodically delete megolm sessions when 2x max_age has passed since receiving the session.
      periodically_delete_expired: false
      # -- Delete inbound megolm sessions that don't have the received_at field used for
      # automatic ratcheting and expired session deletion. This is meant as a migration
      # to delete old keys prior to the bridge update.
      delete_outdated_inbound: false
    # What level of device verification should be required from users?
    #
    # Valid levels:
    #   unverified - Send keys to all device in the room.
    #   cross-signed-untrusted - Require valid cross-signing, but trust all cross-signing keys.
    #   cross-signed-tofu - Require valid cross-signing, trust cross-signing keys on first use (and reject changes).
    #   cross-signed-verified - Require valid cross-signing, plus a valid user signature from the bridge bot.
    #                           Note that creating user signatures from the bridge bot is not currently possible.
    #   verified - Require manual per-device verification
    #              (currently only possible by modifying the `trust` column in the `crypto_device` database table).
    verification_levels:
      # -- Minimum level for which the bridge should send keys to when bridging messages from Signal to Matrix.
      receive: unverified
      # -- Minimum level that the bridge should accept for incoming Matrix messages.
      send: unverified
      # -- Minimum level that the bridge should require for accepting key requests.
      share: cross-signed-tofu
    # -- Enable key sharing? If enabled, key requests for rooms where users are in will be fulfilled.
    # You must use a client that supports requesting keys from other users to use this feature.
    allow_key_sharing: false
    # Options for Megolm room key rotation. These options allow you to
    # configure the m.room.encryption event content. See:
    # https://spec.matrix.org/v1.3/client-server-api/#mroomencryption for
    # more information about that event.
    rotation:
      # -- Enable custom Megolm room key rotation settings. Note that these
      # settings will only apply to rooms created after this option is
      # set.
      enable_custom: false
      # -- The maximum number of milliseconds a session should be used
      # before changing it. The Matrix spec recommends 604800000 (a week)
      # as the default.
      milliseconds: 604800000
      # -- The maximum number of messages that should be sent with a given a
      # session before changing it. The Matrix spec recommends 100 as the
      # default.
      messages: 100

      # -- Disable rotating keys when a user's devices change?
      # You should not enable this option unless you understand all the implications.
      disable_device_change_key_rotation: false


  # Logging config. See https://github.com/tulir/zeroconfig for details.
  logging:
    min_level: warn
    writers:
      - type: stdout
        format: json

  # Messages sent upon joining a management room.
  # Markdown is supported. The defaults are listed below.
  management_room_text:
    # -- Sent when joining a room.
    welcome: "Hello, I'm a Signal bridge bot."
    # -- Sent when joining a management room and the user is already logged in.
    welcome_connected: "Use `help` for help."
    # -- Sent when joining a management room and the user is not logged in.
    welcome_unconnected: "Use `help` for help or `login` to log in."
    # -- Optional extra text sent when joining a management room.
    additional_help: ""

  # Prometheus config.
  metrics:
    # -- Enable prometheus metrics?
    enabled: true
    # -- IP and port where the metrics listener should be. The path is always /metrics
    listen: 0.0.0.0:8000

  signal:
    # -- Displayname template for Signal users. This is also used as the room name in DMs if private_chat_portal_meta is enabled.
    # {{.ProfileName}} - The Signal profile name set by the user.
    # {{.ContactName}} - The name for the user from your phone's contact list. This is not safe on multi-user instances.
    # {{.PhoneNumber}} - The phone number of the user.
    # {{.UUID}} - The UUID of the Signal user.
    # {{.AboutEmoji}} - The emoji set by the user in their profile.
    displayname_template: '{{or .ProfileName .PhoneNumber "Unknown user"}}'
    # -- Should avatars from the user's contact list be used? This is not safe on multi-user instances.
    use_contact_avatars: false
    # -- Should the bridge request the user's contact list from the phone on startup?
    sync_contacts_on_startup: true
    # -- Should the bridge sync ghost user info even if profile fetching fails? This is not safe on multi-user instances.
    use_outdated_profiles: false
    # -- Should the Signal user's phone number be included in the room topic in private chat portal rooms?
    number_in_topic: true
    # -- Default device name that shows up in the Signal app.
    device_name: mautrix-signal
    # Avatar image for the Note to Self room.
    note_to_self_avatar: mxc://maunium.net/REBIVrqjZwmaWpssCZpBlmlL
    # Format for generating URLs from location messages for sending to Signal.
    # Google Maps: 'https://www.google.com/maps/place/%[1]s,%[2]s'
    # OpenStreetMap: 'https://www.openstreetmap.org/?mlat=%[1]s&mlon=%[2]s'
    location_format: 'https://www.openstreetmap.org/?mlat=%[1]s&mlon=%[2]s'

registration:
  # token from config.appservice.id
  # id:
  # taken from config.appservice.address
  # url:
  # taken from config.appservice.as_token default: self-generate
  # as_token:
  # taken from config.appservice.hs_token default: self-generate
  # hs_token:
  # take from config.appservice.bot.username
  # sender_localpart: signalbot
  rate_limited: false
  namespaces:
    users:
      - regex: ^@signalbot:example.org$
        exclusive: true
      - regex: ^@signal_.*:example.org$
        exclusive: true
  de.sorunome.msc2409.push_ephemeral: true
  push_ephemeral: true

serviceAccount:
  # Specifies whether a service account should be created
  create: false
  # Automatically mount a ServiceAccount's API credentials?
  automount: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

livenessProbe:
  httpGet:
    path: /_matrix/mau/live
    port: http
readinessProbe:
  httpGet:
    path: /_matrix/mau/ready
    port: http

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

persistence:
  # -- Enable persistence using Persistent Volume Claims
  # ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  enabled: true
  annotations: {}
  # -- Persistent Volume Storage Class
  # If defined, storageClassName: <storageClass>
  # If set to "-", storageClassName: "", which disables dynamic provisioning
  # If undefined (the default) or set to null, no storageClassName spec is
  #   set, choosing the default provisioner.  (gp2 on AWS, standard on
  #   GKE, AWS & OpenStack)
  storageClass:

  # -- A manually managed Persistent Volume and Claim
  # Requires persistence.enabled: true
  # If defined, PVC must be created manually before volume will be bound
  existingClaim:

  # --  Do not create an PVC, direct use hostPath in Pod
  hostPath:
  # --  accessMode
  accessMode: ReadWriteOnce
  # -- size
  size: 10Gi

prometheus:
  servicemonitor:
    enabled: false
    labels: {}
